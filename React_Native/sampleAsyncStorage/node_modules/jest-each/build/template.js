'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _slicedToArray = (function() {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;
    try {
      for (
        var _i = arr[Symbol.iterator](), _s;
        !(_n = (_s = _i.next()).done);
        _n = true
      ) {
        _arr.push(_s.value);
        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i['return']) _i['return']();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
  return function(arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError(
        'Invalid attempt to destructure non-iterable instance'
      );
    }
  };
})();

exports.default = defaultGlobal =>
  function(_ref) {
    for (
      var _len = arguments.length,
        data = Array(_len > 1 ? _len - 1 : 0),
        _key = 1;
      _key < _len;
      _key++
    ) {
      data[_key - 1] = arguments[_key];
    }

    var _ref2 = _slicedToArray(_ref, 1);

    let headings = _ref2[0];

    const keys = getHeadingKeys(headings);

    const keysLength = keys.length;

    if (data.length % keysLength !== 0) {
      const errorFunction = notEnoughDataError(keys, data);

      const test = errorFunction(defaultGlobal.test);
      test.only = errorFunction(defaultGlobal.test.only);

      const it = errorFunction(defaultGlobal.it);
      it.only = errorFunction(defaultGlobal.it.only);

      const fit = errorFunction(defaultGlobal.fit);

      const describe = errorFunction(defaultGlobal.describe);
      describe.only = errorFunction(defaultGlobal.describe.only);

      const fdescribe = errorFunction(defaultGlobal.fdescribe);

      return {describe, fdescribe, fit, it, test};
    }

    const parameterRows = Array.from({length: data.length / keysLength})
      .map((_, index) =>
        data.slice(index * keysLength, index * keysLength + keysLength)
      )
      .map(row =>
        row.reduce(
          (acc, value, index) => Object.assign({}, acc, {[keys[index]]: value}),
          {}
        )
      );

    const tests = parameterisedTests(parameterRows);

    const globalTest = defaultGlobal.test;
    const test = tests(globalTest);
    test.skip = tests(globalTest.skip);
    test.only = tests(globalTest.only);

    const globalIt = defaultGlobal.it;
    const it = tests(globalIt);
    it.skip = tests(globalIt.skip);
    it.only = tests(globalIt.only);

    const xtest = tests(defaultGlobal.xtest);
    const xit = tests(defaultGlobal.xit);
    const fit = tests(defaultGlobal.fit);

    const globalDescribe = defaultGlobal.describe;
    const describe = tests(globalDescribe);
    describe.skip = tests(globalDescribe.skip);
    describe.only = tests(globalDescribe.only);
    const fdescribe = tests(defaultGlobal.fdescribe);
    const xdescribe = tests(defaultGlobal.xdescribe);

    return {describe, fdescribe, fit, it, test, xdescribe, xit, xtest};
  };

const notEnoughDataError = (keys, data) => cb => title =>
  cb(title, () => {
    throw new Error(
      `Tagged Template Literal test error:\nNot enough arguments supplied for given headings: ${keys.join(
        ' | '
      )}\nReceived: ${data}`
    );
  });

const getHeadingKeys = headings => headings.replace(/\s/g, '').split('|');

const parameterisedTests = parameterRows => globalCb => (title, test) => {
  parameterRows.forEach(params =>
    globalCb(interpolate(title, params), applyTestParams(params, test))
  );
};

const interpolate = (title, data) => {
  const keys = Object.keys(data);
  return keys.reduce((acc, key) => acc.replace('$' + key, data[key]), title);
};

const applyTestParams = (params, test) => {
  if (test.length > 1) return done => test(params, done);

  return () => test(params);
};
